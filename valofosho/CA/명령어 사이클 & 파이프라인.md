# 0904 명령어 사이클 & 파이프라인

# 명령어 사이클

> CPU가 하나의 명령어를 처리하는 정형화된 흐름
> 
- 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행

### 실행 순서

1. **인출 사이클(Fetch Cycle)**:
    - 명령어를 메모리에서 CPU로 가져온다
2. **실행 사이클(Execution Cycle)**
    - CPU로 가져온 명령어를 실행하는 단계
    - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생
3. **간접 사이클(Indirect Cycle)**
    - 명령어를 실행하기 위한 메모리 접근이 한 번 더 필요할 때
4. **인터럽트 사이클(Interrupt Cycle)**
    - CPU의 작업을 방해하는 신호
    - 수행중인 작업에 비해 중요도가 높은 작업을 우선순위로 실행하기 위해 기존의 작업을 잠시 중단
        - 동기 인터럽트(Synchronous Interrupt)
            - CPU에 의해 의해 발생되는 인터럽트
        - 비동기 인터럽트(Asynchronous Interrupt)
            - 주로 입출력 장치에 의해 발생하는 인터럽트
            - 파이썬 실행 시 ctrl+c로 거는 인터럽트

## 명령어 파이프라인

> 명령어를 동시에 처리하여 CPU를 굴리는 기법인 대표적인 명령어 처리 기법 중 하나
> 

### 클럭 단위의 처리 단계

> CPU는 같은 단계가 겹치지만 않는다면 각 단계를 동시에 실행할 수 있다.
> 
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

### 파이프라인 위험(Pipeline Hazard)

> 성능 향상에 실패하는 경우
> 
1. **데이터 위험(Data Hazard)**
    - 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하는 경우 파이프라인이 제대로 작동하지 않는 것
    - 명령어 간 ‘데이터 의존성’에 의해 발생
  
        💡
        
        명령어 1: R1 ← R2 + R3 // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장
        
        명령어 2:R4 ← R1 + R5  //R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4에 저장
        
        ⇒ 명령어 1의 실행이 끝나기 전에 명령어 2를 인출하면 원치 않은 값으로 수행하게 된다.
        
2. **제어 위험(Control Hazard)**  
   - 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생  
   - 프로그램 카운터는 현재 실행중인 명령어의 다음 주소로 갱신  
   → 명령어 실행으로 프로그램 카운터의 값이 바뀜  
   → 미리 파이프라인에 가져와서 처리 중이었던 명령어는 무의미해짐  

    - 분기 예측(Branch Prediction)
        - 프로그램이 어디로 분기할지 미리 예측 후 그 주소를 인출
3. **구조적 위험(Structural Hazard)**
    - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 같은 부품을 사용하려 할 때 발생
    - 자원 위험(Resource Hazard) 라고도 불림
        
        → 동일한 자원에 대한 요청이 겹치면서 문제가 생기기 때문!