# 캐시 메모리

> 빠른 응답을 위해 자주 액세스 하는 정보를 저장하는데 사용되는 데이터 저장소 유형
> 
- 빠른 검색을 위해 최근에 액세스한 데이터를 저장하는 RAM(Random Access Memory)의 한 형태
- 메인 RAM과 CPU 사이에 위치하여 더 빠른 데이터 액세스를 위한 중개자 역할
→ 레지스터보다 용량이 크고 메모리보다 빠른 SRAM기반의 저장 장치

### 등장 배경

- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 개발
- CPU가 매번 연산을 위해 메인 메모리에 찾아가는 시간이 오래 걸림
→ 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리에 가져와서 활용하자!

## 저장 장치 계층 구조

> CPU에서 얼마나 가까운가를 기준으로 계층적으로 나타낸 저장 장치 계층
> 
- 일반적으로 CPU에서 가까운 저장장치일수록 빠르고, 용량이 작고, 비싸다
- 위 계층으로 올라갈수록 
1) CPU와 가깝고 2) 용량이 작고 3) 빠르며 4) 비싸다
- 아래 계층으로 내려갈수록
1) CPU와 멀고 2) 용량이 크고 3) 느리며 4) 저렴하다

<img width="535" height="265" alt="Image" src="https://github.com/user-attachments/assets/5d9ec074-b217-45b6-ba65-05a797e186b5" />

## 캐시 메모리 계층 구조

> CPU와 가까운 순서대로 계층 구성
> 
- 코어와 가까운 순서대로 L1 → L2 → L3 캐시
- 일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치
- 저장 장치 계층과 마찬가지로 코어를 기준으로 가까울수록 빠르고, 용량이 작고, 비싸다

#### CPU의 참조 순서

1. 메모리 내에 데이터가 필요하면 L1 캐시에 해당 데이터가 있는지 탐색
    - L1 캐시의 경우 접근 속도 개선을 위해 분리형 캐시를 사용하는 경우도 있다
        - 명령어만 저장하는 L1l 캐시와 데이터만 저장하는 L1D 캐시로 분리되는 경우
2. 없다면 L2, L3 를 순서대로 검색
    - L1 캐시와 L2 캐시는 코어마다 고유한 캐시 메모리로 할당
    - L3 캐시는 여러 코어가 공유하는 형태로 사

### 참조 지역성 원리

> 메모리에 있는 모든 내용을 저장할 수 없어 아래 두 개의 경험을 바탕으로 만들어진 원리
> 
1. **시간 지역성(Temporal Locality)**
    
    > CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
    > 
    - 프로그램 실행 중 변수가 여러번 참조되는 것처럼 CPU는 최근에 접근했던 (변수가 저장된) 메모리 공간을 여러 번 접근 가능
2. **공간 지역성(Spatial Locality)**
    
    > CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다
    > 
    - CPU가 실행하려는 프로그램과 내부 기능들에 대한 데이터는 보통 관련 데이터들끼리 한데 모여 있다.

### 캐시 적중률(Cache Hit Ratio)
1. 캐시 히트(Cache Hit): CPU가 필요한 데이터가 캐시에 존재하는 경우
2. 캐시 미스(Cache Miss): 캐시에 데이터가 없어 메모리에서 가져와야 하는 경우
- 캐시 성능은 보통 `Hit Ratio = 캐시 히트 횟수 / 전체 접근 횟수`로 표현
  - 일반적으로 캐시 적중률은 90 % 이상이 이상적

#### 캐시 미스 유형
1. Compulsory Miss(Cold Miss)
   - 프로그램이 처음 데이터를 참조할 때 발생
   - 처음에는 캐시와 메모리가 비어있기 때문에 피하기 힘든 Miss
     -block size를 늘리거나 공간 지역성을 활용해 사용될 것 같은 block을 가져와 회피하는 경우도 있다 
2. Capacity Miss
   - 캐시 용량이 부족해서 이전에 불러온 데이터가 쫓겨난 경우 발생
   - 캐시를 크게하여 회피하는 경우도 있지만 access time이 증가한다는 비용이 발생
3. Conflict Miss(Collsion Miss)
   - 캐시 맵핑 방식 때문에 다른 데이터와 충돌하여 쫓겨나는 경우 발생
   - direct나 set associate mapping에서 같은 부분을 번갈아 가면서 사용하게 되서 발생하는 miss
   - fully associate로 바꿔서 회피하는 방법이 있다.

#### 캐시 맵핑 방식

    > CPU 메모리 주소를 캐시에 어떻게 배치할지에 대한 방법
    
  1. 직접 매핑(Direct Mapped Cache)
   - 하나의 메모리 블록이 캐시의 한 위치에만 저장됨
   - 구현이 간단하고 빠르지만 충돌(Conflict Miss)이 자주 발생
  1. 연관 매핑(Fully Associative Cache)
   - 메모리 블록이 캐시의 어떤 라인에도 저장 가능
   - 유연성이 크지만 탐색 속도가 느려지고 구현이 복잡함
  2. 집합 연관 매핑(Set Associative Cache)
   - 직접 매핑과 연관 매핑의 절충안
   - 캐시를 여러 집합(Set)으로 나누고, 각 집합 내에서는 연관 매핑을 사용