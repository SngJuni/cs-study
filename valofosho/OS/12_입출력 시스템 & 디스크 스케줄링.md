# ⚙️ 입출력 시스템 & 디스크 스케줄링 (I/O System & Disk Scheduling)

운영체제에서 **프로세스와 외부 장치 간의 데이터 전송을 관리하는 시스템**  
디스크 스케줄링은 I/O 요청을 효율적으로 처리하기 위한 **디스크 접근 순서 최적화 기법**

---

## 1. 입출력 시스템 (I/O System)

### 🔹 개념
- CPU와 주변장치 간의 **데이터 송수신 관리 구조**
- 입출력 장치의 **속도·종류·데이터 형식 차이**를 추상화 및 통합 제어
- 운영체제가 I/O 요청을 중재하여 **프로세스와 하드웨어 간 통신** 수행

---

## 2. 입출력 시스템 구성요소

| 구성요소 | 설명 | 예시 |
|-----------|------|------|
| **I/O 장치 (Device)** | 데이터를 송수신하는 하드웨어 | 키보드, 디스크, 프린터 |
| **디바이스 컨트롤러 (Device Controller)** | CPU와 장치 간 인터페이스 | SATA, USB 컨트롤러 |
| **디바이스 드라이버 (Device Driver)** | 장치 제어를 위한 소프트웨어 모듈 | `nvme.ko`, `usbcore.ko` |
| **버퍼(Buffer)** | 입출력 데이터 임시 저장 공간 | OS 버퍼 캐시 |
| **인터럽트(Interrupt)** | I/O 완료 시 CPU에 알림 신호 전송 | 디스크 I/O 완료 인터럽트 |

---

## 3. 입출력 동작 과정

```

[User Process]
↓ (System Call)
[OS I/O Subsystem]
↓ (Device Driver)
[Device Controller]
↓ (Hardware)
[I/O Device]

```

### 🔹 단계 요약
1. 사용자 프로세스가 **시스템 콜(system call)**로 I/O 요청  
2. 운영체제가 **디바이스 드라이버**를 통해 명령 전달  
3. **컨트롤러**가 하드웨어에 직접 명령 수행  
4. 작업 완료 후 **인터럽트** 발생 → CPU에 통보  
5. **OS가 버퍼 갱신 및 프로세스 재개**

---

## 4. 입출력 제어 방식

| 방식 | 특징 | 예시 |
|------|------|------|
| **프로그램 제어 I/O (Polling)** | CPU가 I/O 완료까지 대기 | 오래된 임베디드 시스템 |
| **인터럽트 기반 I/O** | I/O 완료 시 CPU에 신호 전송 | 일반 운영체제의 표준 방식 |
| **DMA (Direct Memory Access)** | CPU 개입 없이 메모리-장치 간 직접 전송 | 고속 디스크, 그래픽 카드 |

💡 **예시**
- 키보드 입력 → 인터럽트 기반 제어  
- SSD 데이터 전송 → DMA 기반 제어  

---

## 5. 디스크 구조 이해

| 구성 요소 | 설명 |
|------------|------|
| **플래터 (Platter)** | 자기 물질로 덮인 원판 |
| **트랙 (Track)** | 플래터 표면의 원형 경로 |
| **섹터 (Sector)** | 트랙을 나눈 최소 단위 (512B~4KB) |
| **실린더 (Cylinder)** | 동일 위치의 트랙 집합 |
| **헤드 (Head)** | 데이터를 읽고 쓰는 장치 |
| **암(Arm)** | 헤드를 이동시키는 기계적 부분 |

---

## 6. 디스크 접근 시간 구성

| 구성 요소 | 설명 | 영향 요인 |
|------------|------|------------|
| **탐색 시간 (Seek Time)** | 헤드가 트랙으로 이동하는 시간 | 디스크 스케줄링의 핵심 |
| **회전 지연 (Rotational Latency)** | 섹터가 헤드 아래 도달할 때까지 회전 대기 | RPM(회전 속도)에 비례 |
| **전송 시간 (Transfer Time)** | 데이터를 실제로 읽고 쓰는 시간 | 버스 속도, 블록 크기 |

💡 **총 접근 시간 = 탐색 시간 + 회전 지연 + 전송 시간**

---

## 7. 디스크 스케줄링 알고리즘

### 🎯 목적
- 평균 탐색 시간 최소화  
- 응답 시간 및 처리율 향상  
- 헤드 이동 거리 최소화  

---

### ✅ FCFS (First Come First Serve)

- 요청 순서대로 처리  
- 단순하지만 비효율적

**예시**
```

요청 순서: 98, 183, 37, 122, 14, 124, 65, 67
헤드 시작: 53
→ 총 이동 거리 = 640

```

---

### ✅ SSTF (Shortest Seek Time First)

- **현재 헤드 위치에서 가장 가까운 요청** 우선 처리  
- 평균 탐색 시간 단축, **기아(Starvation)** 가능성 존재

**예시**
```

헤드: 53
요청: 65, 67, 37, 14, 98, 122, 124, 183
→ 처리 순서: 65 → 67 → 37 → 14 → 98 → 122 → 124 → 183
→ 총 이동 거리 = 236

```

---

### ✅ SCAN (엘리베이터 알고리즘)

- 헤드가 한 방향으로 이동하며 요청 처리 후 **끝에서 방향 반전**
- **균형적 응답 시간** 확보

**예시**
```

요청: 14, 37, 65, 67, 98, 122, 124, 183
헤드: 53
→ 진행 방향: 증가 방향
→ 순서: 65 → 67 → 98 → 122 → 124 → 183 → 37 → 14

```

---

### ✅ C-SCAN (Circular SCAN)

- 한쪽 끝까지 이동 후, **반대편으로 점프하여 다시 스캔**
- 모든 요청에 **균등한 대기 시간** 제공

**예시**
```

헤드가 0~199 트랙 존재
현재 헤드: 53
→ 65 → 67 → 98 → 122 → 124 → 183 → (199으로 이동) → (0으로 점프) → 14 → 37

```

---

### ✅ LOOK / C-LOOK

- SCAN, C-SCAN의 개선 버전  
- **요청이 존재하는 범위까지만 이동**  
- 불필요한 트랙 이동 제거

---

## 8. 디스크 스케줄링 비교

| 알고리즘 | 장점 | 단점 | 특징 |
|-----------|------|------|------|
| **FCFS** | 단순, 공정 | 탐색 시간 길음 | 순차 처리 |
| **SSTF** | 평균 탐색 시간 감소 | 기아 발생 가능 | 근접 우선 |
| **SCAN** | 균형적 처리 | 끝단 요청 지연 | 엘리베이터 방식 |
| **C-SCAN** | 일정 응답 시간 | 이동 거리 증가 | 순환 구조 |
| **LOOK** | 효율적 이동 | 구현 복잡 | 요청 범위만 이동 |

---

## 9. 응용 시나리오 예시

| 시나리오 | 적합 알고리즘 | 이유 |
|-----------|----------------|------|
| 고성능 DB 서버 | SSTF / LOOK | 평균 탐색 시간 최소화 |
| 멀티사용자 환경 | C-SCAN | 공정성 확보 |
| 단일 요청 집중형 | FCFS | 단순 처리 구조 |
| 대형 파일 순차 접근 | SCAN | 순차 접근 효율 높음 |

---

## 10. 면접 핵심 질문 예시

| 질문 | 핵심 포인트 |
|------|--------------|
| 디스크 스케줄링의 목적 | 탐색 시간 최소화, 처리율 향상 |
| SSTF의 문제점 | 기아(starvation) 가능성 |
| SCAN과 C-SCAN의 차이 | 방향 반전 여부 vs 순환 스캔 |
| DMA의 장점 | CPU 부하 감소, I/O 효율 향상 |
| 인터럽트 기반 I/O의 이점 | CPU 대기 최소화, 병렬 처리 가능 |
