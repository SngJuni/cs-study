# 📘 파일 접근 방식 (File Access Methods)

파일 시스템에서 데이터를 읽고 쓰는 **접근 순서와 방법**을 정의하는 개념.  
각 방식은 **데이터 구조, 응용 프로그램 목적, 성능 요구**에 따라 선택적으로 사용.

---

## 1. 개념

- 파일에 저장된 데이터를 **어떤 순서와 방식으로 접근할지**를 정의하는 규칙  
- 디스크 상의 물리적 블록과 논리적 레코드를 연결하는 **데이터 접근 전략**  
- 운영체제와 파일 시스템이 데이터를 읽고 쓰는 **기본 메커니즘**

---

## 2. 주요 접근 방식 분류

| 접근 방식 | 설명 | 대표 예시 |
|-------------|------|-------------|
| **순차 접근 (Sequential Access)** | 파일의 시작부터 순차적으로 읽기 및 쓰기 | 텍스트 로그, 음악·동영상 스트리밍 |
| **직접 접근 (Direct Access)** | 파일 내 임의 블록으로 직접 접근 | 데이터베이스, 디스크 인덱스 |
| **색인 접근 (Indexed Access)** | 인덱스 테이블을 통해 특정 레코드에 접근 | 검색 엔진, 파일 검색 시스템 |
| **해시 접근 (Hashed Access)** | 키(key)를 해시 함수로 변환하여 위치 계산 | 키-값 저장소(Key-Value Store) |

---

## 3. 순차 접근 (Sequential Access)

### 🔹 개념
- 가장 기본적인 접근 방식  
- 파일의 **처음부터 끝까지 순서대로 데이터 처리**
- 중간 데이터를 건너뛰는 접근 불가

### 🔹 구조 예시
```

[Record 1] → [Record 2] → [Record 3] → [Record 4]

```

### 🔹 장점
- 단순한 구조  
- 순차적 스트리밍에 적합  
- 버퍼 캐시 효율성 우수  

### 🔹 단점
- 임의 접근 불가  
- 특정 위치 탐색 시 비효율 발생  

### 🔹 실제 예시
| 프로그램 | 사용 예시 |
|-----------|-----------|
| 로그 파일(Log File) | 서버 로그 순차 기록 |
| 동영상 재생기 | 프레임 순차 디코딩 |
| 오디오 스트리밍 | 초 단위 순차 데이터 처리 |

---

## 4. 직접 접근 (Direct Access)

### 🔹 개념
- 파일을 **동일 크기의 레코드 단위로 나누고**, 각 레코드에 **고유 번호(index)**를 부여  
- 원하는 레코드로 **직접 이동(Seek)** 가능  

### 🔹 구조 예시
```

Record 0 | Record 1 | Record 2 | Record 3 | Record 4
↑
직접 접근(Seek)

```

### 🔹 장점
- 빠른 임의 접근 가능  
- 대용량 데이터 처리 효율적  

### 🔹 단점
- 고정된 레코드 크기 필요  
- 구조가 복잡해 관리 어려움  

### 🔹 실제 예시
| 응용 | 설명 |
|------|------|
| 데이터베이스 파일 | `SELECT * FROM table WHERE id=100;` → 특정 레코드 직접 접근 |
| 운영체제 스왑 영역 | 프로세스 메모리 페이지 직접 로드 |
| 영상 편집 소프트웨어 | 특정 프레임 위치로 점프 |

---

## 5. 색인 접근 (Indexed Access)

### 🔹 개념
- **인덱스 블록(index block)** 또는 **테이블**을 별도로 구성하여  
  데이터 블록의 위치를 관리  
- 인덱스를 통해 **빠른 검색 및 정렬 접근** 수행

### 🔹 구조 예시
```

인덱스 테이블
┌────────────┬──────────────┐
│ 키(Key)     │ 블록 번호(Block) │
├────────────┼──────────────┤
│ 101         │ 17           │
│ 205         │ 24           │
│ 309         │ 56           │
└────────────┴──────────────┘

```

### 🔹 장점
- 정렬 및 검색 효율 향상  
- 부분 접근 및 범위 검색 가능  

### 🔹 단점
- 인덱스 유지 관리 비용 발생  
- 추가 저장 공간 필요  

### 🔹 실제 예시
| 응용 | 설명 |
|------|------|
| 데이터베이스 | B+ Tree 인덱스를 통한 검색 |
| 운영체제 파일 탐색 | `find`, `locate` 명령 기반 색인 검색 |
| 문서 검색 시스템 | 단어 → 문서 매핑 인덱스 활용 |

---

## 6. 해시 접근 (Hashed Access)

### 🔹 개념
- **키(key)**를 해시 함수에 넣어 블록 위치를 직접 계산
- 인덱스 없이 즉시 접근 가능

### 🔹 구조 예시
```

## 해시 함수: h(key) = key % 7

## Key | 해시 값 | 저장 블록

101 | 3       | Block 3
208 | 5       | Block 5
321 | 6       | Block 6

```

### 🔹 장점
- 빠른 탐색 속도  
- 키-값 형태 데이터 처리 적합  

### 🔹 단점
- 해시 충돌 문제 존재  
- 정렬 및 순차 접근 불가  

### 🔹 실제 예시
| 응용 | 설명 |
|------|------|
| 키-값 데이터베이스 | Redis, LevelDB |
| 운영체제 캐시 테이블 | inode 캐시, 페이지 캐시 |
| 컴파일러 심볼 테이블 | 변수명 → 메모리 주소 매핑 |

---

## 7. 접근 방식 비교

| 구분 | 순차 접근 | 직접 접근 | 색인 접근 | 해시 접근 |
|------|------------|------------|------------|------------|
| **임의 접근 지원** | ❌ | ✅ | ✅ | ✅ |
| **데이터 구조** | 단순 | 고정 레코드 | 인덱스 테이블 | 해시 테이블 |
| **검색 속도** | 느림 | 빠름 | 빠름 | 매우 빠름 |
| **공간 효율성** | 높음 | 보통 | 낮음 (인덱스 필요) | 높음 |
| **대표 사용처** | 로그, 미디어 | DB, OS | 검색 시스템 | 캐시, 해시맵 |
| **정렬 가능성** | 가능 | 가능 | 가능 | 불가능 |

---

## 8. 응용 시나리오 예시

| 시나리오 | 적용 접근 방식 | 이유 |
|-----------|----------------|------|
| 서버 로그 기록 | 순차 접근 | 시간순 데이터 기록 |
| 영상 스트리밍 | 순차 접근 | 순서 기반 재생 |
| 은행 거래 데이터베이스 | 직접 접근 | 특정 거래내역 즉시 조회 |
| 검색 엔진 인덱스 | 색인 접근 | 빠른 키워드 검색 |
| 캐시 메모리 관리 | 해시 접근 | 해시 키 기반 빠른 탐색 |

---

## 9. 면접 핵심 질문 예시

| 질문 | 핵심 포인트 |
|------|--------------|
| 순차 접근의 특징 | 순서대로 읽고 쓰는 구조, 단순하지만 느림 |
| 직접 접근과 색인 접근의 차이 | 직접은 고정 블록 기반, 색인은 별도 인덱스 활용 |
| 해시 접근의 단점 | 충돌 발생 가능성, 정렬 불가 |
| 데이터베이스에서 사용하는 접근 방식 | 색인 + 직접 접근 혼합 구조 |
| 운영체제에서 사용하는 접근 방식 예시 | inode 기반 인덱스 접근, FAT 연결 접근 |
