# 🧠 시스템 콜 & 운영체제 구조 (System Call & OS Structure)

운영체제가 사용자 프로그램과 하드웨어 사이에서  
**자원 관리 및 서비스 제공을 담당하는 핵심 메커니즘**

---

## 1. 시스템 콜 (System Call)

### 🔹 개념
- 사용자 프로그램이 **운영체제의 커널 기능을 요청**하는 인터페이스  
- **사용자 모드(User Mode)** 에서 **커널 모드(Kernel Mode)** 로 전환되는 과정 포함  
- 하드웨어 접근을 안전하게 제한하고 **보안·안정성 확보** 역할 수행  

---

## 2. 시스템 콜의 필요성

| 구분 | 이유 | 예시 |
|------|------|------|
| **보안성** | 사용자 프로그램이 하드웨어를 직접 조작하는 행위 차단 | 메모리 침범 방지 |
| **추상화** | 복잡한 장치 제어를 단순화 | `read()`, `write()` |
| **자원 관리** | CPU, 메모리, 파일 등 공유 자원 효율적 분배 | 프로세스 스케줄링 |
| **오류 처리** | 하드웨어 및 커널 오류 처리 통일 | 예외 처리 루틴 호출 |

---

## 3. 시스템 콜의 구조 및 흐름

```

User Process
│
│ ① 시스템 콜 요청 (예: read())
▼
System Call Interface
│
│ ② 커널 진입 (Trap / Interrupt)
▼
Kernel Mode (OS Core)
│
│ ③ 실제 자원 접근 및 처리
▼
│ ④ 결과 반환 (상태 코드, 데이터 등)
▼
User Process 재개

```

💡 **핵심 개념**
- **Trap**: 사용자 모드에서 커널 모드로의 제어 이전  
- **Mode Bit**: CPU가 현재 실행 중인 모드를 구분하는 플래그  

---

## 4. 시스템 콜의 주요 분류

| 분류 | 설명 | 예시 |
|------|------|------|
| **프로세스 제어 (Process Control)** | 프로세스 생성, 종료, 스케줄링 | `fork()`, `exec()`, `exit()` |
| **파일 조작 (File Manipulation)** | 파일 생성, 읽기, 쓰기, 닫기 | `open()`, `read()`, `write()`, `close()` |
| **장치 조작 (Device Manipulation)** | I/O 장치 접근 및 설정 | `ioctl()`, `read()` |
| **정보 유지 (Information Maintenance)** | 시간, 속성, 자원 상태 조회 | `getpid()`, `gettimeofday()` |
| **통신 (Communication)** | 프로세스 간 메시지 교환 | `pipe()`, `send()`, `recv()` |

---

## 5. 시스템 콜 예시 (UNIX 기반)

| 호출 함수 | 기능 | 반환값 예시 |
|------------|------|-------------|
| `fork()` | 자식 프로세스 생성 | 0 (자식), PID (부모) |
| `exec()` | 새로운 프로그램으로 교체 실행 | 성공 시 반환 없음 |
| `wait()` | 자식 종료 대기 | 종료된 PID |
| `open()` | 파일 열기 | 파일 디스크립터(fd) |
| `read(fd, buf, n)` | 데이터 읽기 | 읽은 바이트 수 |
| `write(fd, buf, n)` | 데이터 쓰기 | 기록한 바이트 수 |
| `exit()` | 프로세스 종료 | 반환 없음 |

---

## 6. 사용자 모드와 커널 모드

| 구분 | 역할 | 접근 가능 자원 | 전환 트리거 |
|------|------|----------------|--------------|
| **사용자 모드 (User Mode)** | 응용 프로그램 실행 | 제한된 메모리 공간 | 시스템 콜 호출 |
| **커널 모드 (Kernel Mode)** | OS 핵심 기능 수행 | 모든 하드웨어 자원 | Trap, Interrupt |

💡 예시  
- `printf()` → 사용자 수준 라이브러리 함수  
- `write()` → 실제 커널 시스템 콜 (커널 모드 진입)

---

## 7. 운영체제 구조 (OS Structure)

운영체제는 기능적 복잡성을 관리하기 위해 **계층적 구조 또는 모듈화된 설계 방식**을 채택

---

### ✅ 단일 구조 (Monolithic Structure)
- 모든 기능이 **하나의 커널 공간에 통합**
- 빠른 처리 속도, 디버깅 및 유지보수 어려움

**예시**
```

User Application
↓
[Single-layer Kernel]
→ 시스템 콜, 파일 관리, 메모리 관리, I/O 통합 수행

```
🧩 대표 OS: UNIX, MS-DOS

---

### ✅ 계층형 구조 (Layered Structure)
- 기능을 **계층(Layer)** 별로 분리  
- 상위 계층은 하위 계층을 호출하는 구조

| 계층 | 기능 예시 |
|------|------------|
| Layer 0 | 하드웨어 제어 |
| Layer 1 | CPU 스케줄링, 메모리 관리 |
| Layer 2 | 파일 시스템, I/O |
| Layer 3 | 사용자 인터페이스, 시스템 콜 |

🧩 대표 OS: THE Operating System (Edsger Dijkstra 설계)

---

### ✅ 마이크로커널 구조 (Microkernel)
- 최소한의 핵심 기능만 커널에 포함  
- 나머지는 사용자 공간의 **서버 프로세스**로 분리

**핵심 기능**
- 프로세스 간 통신(IPC)
- 메모리 관리, 스케줄링, 인터럽트 처리

**장점**
- 모듈화, 이식성, 보안성 우수
  
**단점**
- 커널과 사용자 간 통신 오버헤드

🧩 대표 OS: macOS (XNU 커널), QNX, MINIX

---

### ✅ 모듈형 커널 (Modular Kernel)
- 커널 내부에 **동적 로딩 가능한 모듈**을 포함  
- 필요 시 기능만 로드/언로드 가능  

💡 예시  
`Linux Kernel`의 `.ko` 모듈 (`usbcore.ko`, `nvme.ko` 등)

---

## 8. 운영체제 구조 비교

| 구조 | 장점 | 단점 | 대표 OS |
|------|------|------|----------|
| **단일형 (Monolithic)** | 빠른 실행 속도 | 유지보수 어려움 | UNIX, MS-DOS |
| **계층형 (Layered)** | 구조 명확, 테스트 용이 | 설계 복잡 | THE System |
| **마이크로커널** | 보안성, 모듈화 | 성능 저하 | macOS, MINIX |
| **모듈형 커널** | 유연성, 기능 확장 | 버전 의존성 | Linux |

---

## 9. 시스템 콜과 OS 구조의 관계

| 측면 | 시스템 콜 역할 | 구조적 영향 |
|------|----------------|--------------|
| **인터페이스** | 사용자 ↔ 커널 연결 | OS 구조 상단에 위치 |
| **보안** | 커널 접근 통제 | 마이크로커널에서 핵심 |
| **성능** | Trap 빈도에 따라 I/O 효율 결정 | 단일형에서 유리 |
| **확장성** | 새로운 서비스 추가 용이 | 모듈형에서 유리 |
