# 시스템 콜(System Call) & 운영체제 구조(OS Structure)

## 1. 시스템 콜(System Call)

### 1.1 개념  
**운영체제의 서비스를 사용자 프로그램이 이용하기 위한 인터페이스** 
즉, **사용자 프로그램이 커널에 기능을 요청하는 방법**을 제공함.  

예를 들어, 파일을 열거나 프로세스를 생성하는 등의 작업은  
사용자 프로그램이 직접 하드웨어에 접근할 수 없기 때문에, **시스템 콜을 통해 커널이 대신 수행**함.

---

### 1.2 시스템 콜의 역할  

1. **사용자 프로그램과 커널 간의 인터페이스 제공**  
   - 사용자 모드(User Mode)에서 커널 모드(Kernel Mode)로 전환  

2. **보안과 안정성 확보**  
   - 직접 하드웨어 접근을 제한하여 시스템 오류 방지  

3. **자원 관리 요청**  
   - CPU, 메모리, 파일 등 자원에 대한 접근 요청 수행  

---

### 1.3 시스템 콜의 동작 과정  

1. 사용자 프로그램이 시스템 콜 호출 (예: `read()`, `write()`)  
2. 커널 모드로 전환 (Trap 명령 실행)  
3. 커널이 요청된 작업 수행  
4. 수행 결과를 사용자 프로그램에 반환  
5. 다시 사용자 모드로 복귀  

사용자 프로그램

↓ (시스템 콜 호출)

운영체제 커널

↓ (하드웨어 제어)

하드웨어

---

### 1.4 주요 시스템 콜의 종류  

| 분류 | 설명 | 예시 |
|------|------|------|
| **프로세스 제어(Process Control)** | 프로세스 생성, 종료, 상태 관리 | `fork()`, `exec()`, `exit()`, `wait()` |
| **파일 조작(File Manipulation)** | 파일 읽기, 쓰기, 삭제, 접근 제어 | `open()`, `read()`, `write()`, `close()` |
| **디바이스 관리(Device Management)** | 장치 요청 및 해제 | `ioctl()`, `read()`, `write()` |
| **정보 유지(Information Maintenance)** | 시스템 시간, 프로세스 정보 등 관리 | `getpid()`, `alarm()`, `time()` |
| **통신(Communication)** | 프로세스 간 통신(IPC) | `pipe()`, `shmget()`, `send()`, `recv()` |

---

# 운영체제 구조 (OS Structure)

## 1. 운영체제 구조의 개념  

운영체제 구조(OS Structure)란 **운영체제의 구성 요소들을 어떻게 설계하고 조직할 것인지에 대한 구조적 설계 방식**을 말함.  
운영체제는 매우 복잡하기 때문에, **효율성·안정성·유지보수성**을 고려하여 여러 가지 구조로 나뉨.

---

## 2. 운영체제 구조의 종류  

### 2.1 단일 구조 (Monolithic Structure)

운영체제의 모든 기능이 **하나의 커널(Kernel)** 내부에 통합되어 있는 구조임.  
즉, 파일 관리, 프로세스 관리, 입출력 관리 등 모든 기능이 **하나의 거대한 코드 블록** 안에서 동작함.

#### 특징  
- 모든 서비스가 커널 공간에서 직접 실행됨  
- 모듈 간 구분이 거의 없음  

#### 장점  
- 성능이 빠름 (함수 호출 오버헤드가 적음)  
- 구현이 단순함  

#### 단점  
- 오류가 발생하면 전체 시스템이 다운될 위험 있음  
- 유지보수 및 수정이 어려움  

#### 예시  
- **MS-DOS**, **초기 UNIX**  

[ 사용자 프로그램 ]

↓

[ 커널(파일, 메모리, 프로세스 등 전체 기능 포함) ]


---

### 2.2 계층형 구조 (Layered Structure)

운영체제를 여러 **계층(layer)**으로 나누어, **각 계층이 바로 아래 계층의 기능만 이용하도록 설계한 구조**임.

#### 특징  
- 하위 계층은 상위 계층에 서비스 제공  
- 계층 간 의존성을 최소화함  

#### 장점  
- 설계와 디버깅이 쉬움  
- 유지보수가 용이함  

#### 단점  
- 계층 간 호출이 많아져 성능이 떨어질 수 있음  
- 계층 설계가 복잡할 수 있음  

#### 예시  
- **THE 시스템**, **Modern layered UNIX 구조 일부**  

[ 사용자 프로그램 ]

[ 운영체제 서비스 계층 ]

[ 메모리/파일/프로세스 관리 계층 ]

[ 하드웨어 제어 계층 ]


---

### 2.3 마이크로커널 구조 (Microkernel Structure)

운영체제의 **핵심 기능(프로세스 관리, 메모리 관리, IPC 등)**만 커널에 포함하고,  
나머지 기능(파일 시스템, 장치 드라이버 등)은 **사용자 공간(User Space)**에서 실행하는 구조임.

#### 특징  
- 커널 크기를 최소화하여 안정성과 보안성 강화  
- 서비스 간 통신은 메시지 전달(IPC)을 통해 이루어짐  

#### 장점  
- 오류가 커널 전체에 영향을 주지 않음 (안정성 높음)  
- 확장 및 유지보수 용이  

#### 단점  
- 커널-사용자 간 통신 오버헤드로 인해 성능 저하 가능  

#### 예시  
- **macOS (Darwin 커널)**  
- **QNX**, **Minix**, **L4 커널**  

[ 사용자 프로세스 (파일, 네트워크, GUI 등) ]

↓

[ 마이크로커널 (IPC, 스케줄링, 메모리 관리 등) ]


---

### 2.4 모듈형 구조 (Modular Structure)

운영체제를 여러 **독립된 모듈(Module)**로 나누어, 필요에 따라 동적으로 추가하거나 제거할 수 있는 구조임.  
각 모듈은 커널과 명확한 인터페이스를 통해 통신함.

#### 특징  
- 각 기능이 독립된 모듈로 구성됨  
- 커널에 필요한 기능만 로드 가능 (동적 로딩)  

#### 장점  
- 유연하고 확장성 높음  
- 유지보수가 쉬움  

#### 단점  
- 모듈 간 의존성 관리가 필요함  

#### 예시  
- **Linux 커널 (LKM: Loadable Kernel Module)**  

[ 커널 코어 ]

├── 파일 시스템 모듈

├── 네트워크 모듈

└── 디바이스 드라이버 모듈


---

### 2.5 하이브리드 구조 (Hybrid Structure)

**단일형 구조 + 마이크로커널 구조의 장점을 결합한 형태**임.  
커널 내부에 일부 핵심 기능은 포함하되, 나머지 기능은 모듈 형태로 분리하여 실행함.

#### 특징  
- 성능과 안정성의 균형을 맞춘 구조  
- 마이크로커널보다 빠르고, 단일형보다 안정적임  

#### 장점  
- 높은 효율성과 안정성  
- 다양한 하드웨어 지원 가능  

#### 단점  
- 설계가 복잡함  

#### 예시  
- **Windows NT / Windows 10**  
- **macOS (하이브리드 Darwin 커널)**  

[ 사용자 공간 (서비스, 드라이버 등) ]

↓

[ 하이브리드 커널 (핵심 기능 + 모듈화된 서비스) ]


---

## 3. 운영체제 구조 비교  

| 구조 | 핵심 특징 | 장점 | 단점 | 대표 예시 |
|------|-------------|------|------|------------|
| 단일형 | 모든 기능이 하나의 커널에 통합 | 빠른 성능 | 유지보수 어려움 | MS-DOS, 초기 UNIX |
| 계층형 | 계층별 기능 분리 | 구조 명확 | 계층 호출 오버헤드 | THE 시스템 |
| 마이크로커널 | 최소 커널, 나머지는 사용자 공간 | 안정성 높음 | 성능 낮을 수 있음 | macOS, Minix |
| 모듈형 | 커널 + 독립 모듈 | 확장성 우수 | 의존성 관리 필요 | Linux |
| 하이브리드 | 단일형+마이크로커널 혼합 | 효율성과 안정성 균형 | 설계 복잡 | Windows NT, macOS |

---
