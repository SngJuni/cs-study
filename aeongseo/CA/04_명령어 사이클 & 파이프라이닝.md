# 명령어 사이클 (Instruction Cycle)

## 개념
- CPU가 **명령어 하나를 가져와 실행하는 전체 과정**  
- 한 명령어의 수행 과정을 **연속된 단계**로 나누어 반복

## 단계별 설명
1. **인출(Fetch)**
   - PC(Program Counter)가 가리키는 주소에서 명령어를 가져와 IR(명령어 레지스터)에 저장  
   - 예: `ADD R1, R2` 명령어를 메모리에서 가져오기
2. **해독(Decode)**
   - 제어장치가 명령어를 분석  
   - 연산 종류와 필요한 레지스터/메모리 확인  
   - 예: ADD → ALU가 덧셈 연산 준비, R1/R2 읽기
3. **실행(Execute)**
   - ALU나 다른 연산 장치가 실제 연산 수행  
   - 예: R1 + R2 연산
4. **메모리 접근(Memory Access, 필요시)**
   - Load/Store 명령어일 때 메모리 읽기/쓰기 수행  
   - 예: `LOAD R3, 100H` → 메모리 주소 100H 값을 R3에 저장
5. **쓰기(Write-back)**
   - 연산 결과를 레지스터나 메모리에 기록  
   - 예: 덧셈 결과를 R1에 저장

## 특징
- **단일 명령어 지연 시간(Latency)** 중심  
- 구조 단순 → 이해 및 구현 용이  
- 병렬 처리 X → CPU 처리율 제한

<br>
<br>

# 파이프라이닝 (Pipelining)

## 개념
- 명령어 사이클의 단계를 **겹쳐서 동시에 수행**  
- CPU 자원을 효율적으로 활용하여 **처리율(Throughput) 증가**  
- 비유: 세탁기 1대 → 순차적 단계, 세탁기 3대 → 각 단계 동시에 처리

## 대표 5단계 파이프라인
1. IF: Instruction Fetch  
2. ID: Instruction Decode  
3. EX: Execute  
4. MEM: Memory Access  
5. WB: Write Back  

- 예시:  
    - 명령어 1은 EX 단계 수행 중  
    - 명령어 2는 ID 단계 수행  
    - 명령어 3은 IF 단계 수행  
        → 동시에 3개의 명령어가 서로 다른 단계 진행

## 장점
- **Throughput 증가** → 단위 시간에 더 많은 명령어 실행 가능  
- CPU 자원 활용 극대화

## 문제점 (Hazard)
- **구조적 해저드(Structural Hazard)**  
   - 같은 자원을 동시에 접근하려 할 때  
   - 예: 한 메모리에서 명령어와 데이터 동시에 접근 필요
- **데이터 해저드(Data Hazard)**  
   - 앞 명령어 결과가 필요하지만 아직 계산 안 됨  
   - 예: `ADD R1,R2` → 바로 다음 명령어 `SUB R3,R1`에서 R1 필요
- **제어 해저드(Control Hazard)**  
   - 분기 명령어(BRANCH) 실행 시 다음 명령어 주소 불확실  
   - 예: `BEQ R1,R2,LABEL` → 분기 여부에 따라 다음 IF 주소 결정

## 해결 기법
- **포워딩(Forwarding)**: 연산 결과를 다음 명령어에 바로 전달  
- **파이프라인 스톨(Stall)**: 잠시 대기 후 진행  
- **분기 예측(Branch Prediction)**: 분기 결과를 미리 예측


# 명령어 사이클 vs 파이프라이닝 비교

| 명령어 사이클 | 구분 | 파이프라이닝 |
|----------------|------|----------------|
| 한 명령어씩 순차 처리 | 처리 방식 | 여러 명령어 동시 단계 처리 |
| 지연 시간(Latency) 중심 | 성능 | 처리율(Throughput) 중심 |
| 단순 구조, 구현 용이 | 장점 | CPU 자원 효율적 활용, 처리 속도 ↑ |
| 느림 | 단점 | 해저드(Hazard) 관리 필요, 구조 복잡 |
| 줄 서서 하나씩 계산 | 비유 | 컨베이어 벨트에서 동시에 여러 작업 |
