# RISC vs CISC

## ISA (Instruction Set Architecture)

- CPU가 실행할 수 있는 기계어 명령어들의 집합

### 역할
- 하드웨어(CPU)와 소프트웨어(컴파일러, OS 등) 사이의 인터페이스 역할
- 어떤 연산 지원하는지, 어떤 데이터 형식 다루는지, 메모리 접근 방식이 무엇인지 규정

### 구성요소
- 명령어 형식 (Instruction Format)
- 주소 지정 방식 (Addressing Mode)
    - 피연산자가 메모리의 어느 위치에 있는지 지정하는 방법 정의
    - ex. 명령어에 데이터 값 직접 포함, 데이터가 저장된 메모리 주소 가리킴
- 데이터 타입
    - 프로세서가 직접 처리할 수 잇는 데이터의 종류와 크기 정의
    - ex. 8비트 정수, 32비트 부동소수점 숫자
- 레지스터 구조
    - 프로그래머가 직접 사용할 수 있는 레지스터들의 개수, 종류, 용도 정의

## CISC (Complex Instruction Set Computer)

---

### 개념

- 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식
- 한 개의 명령어로 여러 단계를 수행할 수 있게 함 (ex. 메모리 접근 + 연산 + 저장 한번에)
- ex. x86, x86-64

### 특징

- 명령어의 종류가 많고 복잡함
- 명령어 길이가 가변적
- 하드웨어 복잡 → 명령어 해석기가 무겁고, 파이프라이닝 효율 떨어질 수 있음
- 메모리 접근을 명령어 안에서 직접 포함하는 경우 많음

### 장점

- 어셈블리 코드 간결
- 크기 줄이는 데 유리

### 단점

- 복잡한 명령어들은 대부분 실제로 잘 사용 X
- 하드웨어 설계와 최적화 어려움

## RISC (Reduced Instruction Set Computer)

### 개념

- 단수하고 규칙적인 명령어들을 지원
- 대부분의 명령어가 한 클럭 주기(1 cycle)에 실행되도록 단순화
- ex. ARM, MIPS, RISC-V, SPARC

### 특징

- 명령어 종류 적고 단순
- 명령어 길이 고정적
- 메모리 접근은 Load / Store 명령어로만 수행 (연산 명령어는 오직 레지스터끼리)
- 파이프라이닝에 최적화

### 장점

- 하드웨어 단순 → 성능 최적화 및 고속 동작 가능
- 파이프라인, 슈퍼스칼라 등 현대 CPU 기법과 잘 맞음

### 단점

- 어셈블리 코드가 길어져 메모리 사용량 증가

## CISC vs RISC 비교


| CISC | 구분 | RISC |
| --- | --- | --- |
| 많음, 복잡 | 명령어 수 | 적음, 단순 |
| 가변적 | 명령어 길이 | 고정적 |
| 명령어에서 직접 가능 | 메모리 접근 | Load/Store 방식 |
| 여러 사이클 필요 | 실행 사이클 | 대부분 1 사이클 |
| 복잡 (명령어 해석기 큼) | 하드웨어 | 단순, 파이프라인 최적화 |
| 짧음 | 코드 길이 | 김 |