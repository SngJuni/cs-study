# 페이징 & 세그멘테이션

## 페이징 (Paging)

### 개념

- 메모리를 **고정된 크기(보통 수 KB 단위)**의 블록으로 나누어 관리하는 방법.
- **프로세스의 논리 주소 공간**과 **물리적 메모리(RAM)**를 같은 크기의 블록 단위로 나눔.
    - 논리 메모리의 블록: **페이지(Page)**
    - 물리 메모리의 블록: **프레임(Frame)**

### 동작 방식

1. 프로세스는 여러 개의 페이지로 쪼개짐.
2. 운영체제는 빈 프레임을 찾아 각 페이지를 적재.
3. *페이지 테이블(Page Table)**을 통해 논리적 주소 → 물리적 주소 변환.

### 장점

- 외부 단편화(External Fragmentation)가 없음. (고정 크기로 나누므로)
- 메모리를 효율적으로 사용할 수 있음.

### 단점

- 내부 단편화(Internal Fragmentation) 발생 가능. (프레임 크기보다 작은 페이지는 남는 공간이 생김)
- 주소 변환 과정이 복잡 → 오버헤드 증가.

## 세그멘테이션 (Segmentation)

### 개념

- 메모리를 **논리적 단위(의미 단위)**에 따라 나누는 방법.
- 프로그램은 코드, 데이터, 스택 등 여러 **세그먼트(Segment)**로 구분됨.
- 세그먼트마다 길이가 다름 → 가변 크기 블록.

### 동작 방식

1. 프로세스는 여러 세그먼트(코드, 함수, 배열 등)로 나뉨.
2. 각 세그먼트는 **세그먼트 테이블(Segment Table)**을 통해 관리.
    - 엔트리: 시작 주소(base) + 세그먼트 크기(limit).
3. 주소 변환 시:
    - (세그먼트 번호, 오프셋) 형태 → base + offset 으로 물리 주소 계산.

### 장점

- 사용자가 논리적으로 이해하기 쉬움 (코드, 스택, 데이터 등 구분).
- 공유와 보안이 용이 (세그먼트 단위 접근 제어).

### 단점

- 외부 단편화 발생 가능 (가변 크기이므로 남는 공간이 흩어짐).
- 메모리 관리가 복잡해짐.