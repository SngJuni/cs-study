# 시스템 콜 & OS 구조

## 시스템 콜 (System Call)

### 커널

- 하드웨어를 직접 제어하고 자원을 관리하는 프로그램
- 주요 역할
    - 프로세스 관리
    - 메모리 관리
    - 파일 시스템 관리
    - 입출력 관리

### 시스템 콜

- 사용자 프로그램이 커널 기능을 요청하는 인터페이스
- 사용자 모드 → 커널 모드로 전환하는 유일한 방법

### 필요성

- 사용자 프로그램은 하드웨어에 직접 접근 X
- 시스템 콜이 요청하여 운영체제가 대신 수행

### 동작 과정

1. 사용자 프로그램이 라이브러리 함수 호출
2. 시스템 콜 인터페이스가 트랩(Trap) 명령 발생
3. 커널 모드로 전환
4. 운영체제가 요청된 작업 수행
5. 결과를 사용자 모드로 복귀
- Trap → 커널 모드 전환 → 처리 → 복귀

### 시스템 콜 종류

- 프로세스 제어 : `fork()`, `exec()`, `exit()`, `wait()`
- 파일 조작 : `open()`, `read()`, `write()`, `close()`
- 디바이스 관리 : `ioctl()`, `read()`, `write()`
- 정보 유지 : `getpid()`, `alarm()`, `sleep()`
- 통신 : `pipe()`, `send()`, `recv()`

## 운영체제 구조

- 내부적으로 여러 기능을 어떻게 나눌지에 따라 구조 달라짐

### Monolithic Kernel (단일 구조)

- 모든 기능이 하나의 커널 안에 존재
- 함수 호출로 직접 접근 가능 → 빠름
- 유지 보수 어려움, 안정성 낮음 (하나가 오류나면 전체 다운)

### Layered OS (계층 구조)

- 기능을 계층별로 나눔 (하드웨어 ↔ 커널 ↔ 사용자 인터페이스)
- 하위 계층 기능을 상위 계층이 이용
- 구조 깔끔, 디버깅 쉬움
- 성능 약간 떨어짐

### Microkernel (마이크로커널 구조)

- 커널에는 최소한의 기능(프로세스, 메모리, IPC)만 남기고 나머지는 유저 모드 서비스로 분리
- 안정성, 확장성 높음 (한 서비스가 죽어도 커널은 정상 작동)
- 성능은 다소 느림 (모드 전환 많음)
- ex. macOS, Windows NT

### Modular Kernel (모듈형 커널)

- monolithic + microkernel의 절충형
- 커널의 핵심 기능 포함 + 모듈을 동적으로 로딩 가능
- 현재 Linux 구조

## 사용자 모드 vs 커널 모드

| 구분 | 사용자 모드 | 커널 모드 |
| --- | --- | --- |
| 권한 | 제한적 | 모든 권한 보유 |
| 접근 가능 자원 | 사용자 영역 메모리 | 시스템 자원 전체 |
| 예시 | 앱, 게임, 브라우저 | 커널, 드라이버 |
| 전환 방법 | 시스템 콜 호출 시 | 트랩 종료 시 복귀 |