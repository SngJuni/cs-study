## **CPU 스케줄링 알고리즘**

### 📌 한줄 요약
**CPU 스케줄링**은 여러 프로세스에게 한정된 CPU 자원을 효율적으로 배분하기 위한 정책이며, 어떤 프로세스를 언제 실행할지 결정하는 운영체제의 핵심 기능이다.

--- 

### **1. 스케줄링의 목표와 평가 척도**

"좋은" 스케줄링이란 무엇일까? 이는 시스템의 목적에 따라 다르며, 주로 다음 척도들을 통해 평가된다.

* **CPU 이용률 (CPU Utilization)**: 전체 시간 중 CPU가 실제로 작업을 처리한 시간의 비율. (높을수록 좋음)
* **처리량 (Throughput)**: 단위 시간당 완료된 프로세스의 개수. (많을수록 좋음)
* **반환 시간 (Turnaround Time)**: 프로세스가 시스템에 제출된 순간부터 완료될 때까지 걸린 총 시간.
* **대기 시간 (Waiting Time)**: 프로세스가 준비 큐(Ready Queue)에서 CPU를 기다리며 보낸 시간의 총합.
* **응답 시간 (Response Time)**: 사용자가 요청을 보낸 후, 첫 번째 응답이 오기까지 걸리는 시간. (대화형 시스템에서 중요)

---

### **2. 선점형 vs. 비선점형 스케줄링**

스케줄러가 실행 중인 프로세스의 CPU 제어권을 빼앗을 수 있는지 여부에 따라 두 가지 방식으로 나뉜다.

* **비선점형 (Non-preemptive)**: 한 프로세스가 CPU를 할당받으면, 해당 작업이 끝나거나 자발적으로 대기 상태에 들어가기 전까지는 누구도 CPU를 빼앗을 수 없다.
- 운영체제가 강력한 권한(=제어권)이 없다.
    * **장점**: 문맥 교환 오버헤드가 적다.
    * **단점**: 긴 작업 하나가 짧은 작업 여러 개를 무한정 기다리게 할 수 있다.
    *  **예시**: FCFS, SJF, HRN((대기시간 + 실행시간)/(실행시간)이 높은 순), 우선순위, 기한부

* **선점형 (Preemptive)**: 운영체제가 필요하다고 판단하면(예: 할당된 시간이 끝나거나, 더 중요한 작업이 도착하면), 현재 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스에 CPU를 할당할 수 있다.
- 운영체제가 강력한 권한(=제어권)을 갖고 있기 때문에 가능하다.
    * **장점**: 응답 시간이 빠르고, 모든 프로세스가 공평하게 CPU를 사용할 기회를 얻는다.
    * **단점**: 잦은 문맥 교환으로 인한 오버헤드가 발생할 수 있다.
    * **예시**: RR, SRT, MLQ, MLFQ

---

### **3. 주요 스케줄링 알고리즘**


### **비선점형 스케줄링 알고리즘**

#### **① FCFS (First-Come, First-Served)**(=FIFO)
> **"먼저 온 순서대로 처리"**

* **방식**: 비선점형
* **설명**: 준비 큐에 도착한 순서대로 CPU를 할당하는 가장 간단한 방식이다.
* **단점**: **호위 효과(Convoy Effect)**가 발생할 수 있다. 실행 시간이 매우 긴 프로세스가 먼저 도착하면, 그 뒤의 짧은 프로세스들이 모두 하염없이 기다려야 해서 평균 대기 시간이 급격히 길어진다.

#### **② SJF (Shortest Job First)**
> **"가장 짧게 끝날 작업부터 처리"**

* **방식**: 비선점형 (선점형 버전은 **SRT(Shorteset-Remain-Time)**라고 부른다)
* **설명**: 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧을 것으로 예상되는 것을 먼저 실행한다.
* **장점**: 평균 대기 시간을 최소화하는, 이론적으로 가장 효율적인 알고리즘이다.
* **단점**:
    * **실행 시간 예측의 어려움**: 실제 실행 시간을 미리 알 수 없으므로 과거 데이터를 통해 추정해야 한다.
    * **기아 현상 (Starvation)**: 짧은 작업들이 계속 도착하면, 긴 작업은 영원히 실행되지 못할 수 있다. **(HRN 알고리즘은 이 문제를 해결하기 위해 제안되었다.)**


#### **③ HRN (Highest Response Ratio Next)**
> **"기다린 시간을 고려하여 우선순위를 동적으로 결정"**

SJF의 단점인 **기아 현상(Starvation)**을 보완하기 위해 만들어진 알고리즘이다. 우선순위를 계산할 때 대기 시간도 함께 고려한다.

* **우선순위 계산식**: `(대기 시간 + 실행 시간) / 실행 시간`
* **동작 방식**: 이 계산식의 결과값이 가장 높은 프로세스를 다음에 실행한다.
    * 실행 시간이 짧은 프로세스는 분모가 작아져 우선순위가 높아진다. (SJF의 장점)
    * 실행 시간이 길더라도 대기 시간이 길어지면 분자가 커져 결국 우선순위가 높아진다. (기아 현상 방지)

#### **④ 우선순위 (Priority)**
> **"중요도(우선순위)가 높은 작업부터 처리"**

* **방식**: 선점형 또는 비선점형
* **설명**: 각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스에 CPU를 할당한다.
* **단점**: **기아 현상 (Starvation)**. 낮은 우선순위의 프로세스는 영원히 실행되지 못할 수 있다. **(이를 해결하기 위해 '노화(Aging)' 기법을 사용한다.)**

#### **⑤ 기한부 (Deadline)**
> **"마감 기한이 가장 임박한 작업부터 처리"**

**실시간 운영체제(RTOS)**에서 주로 사용되는 방식으로, 모든 작업에 **마감 시간(Deadline)**이 부여된다. 스케줄러는 이 마감 시간을 어기지 않는 것을 최우선 목표로 작업을 스케줄링한다. (예: 자동차 에어백 제어, 항공기 운항 시스템)

---

### **선점형 스케줄링 알고리즘**

#### **① RR (Round Robin)**
> **"정해진 시간(Time Quantum)만큼 번갈아 가며 처리"**

* **방식**: 선점형
* **설명**: **시분할 시스템(Time-sharing system)을 위해 설계된 대표적인 선점형 스케줄링 방식이다.** FCFS 알고리즘을 기반으로, 각 프로세스가 CPU를 사용할 수 있는 고정된 시간(**시간 할당량, Time Quantum**)을 부여한다.
* **장점**: 모든 프로세스가 공평하게 CPU 시간을 얻으며, 응답 시간이 짧아 현대적인 **대화형 시분할 시스템**에 적합하다.
* **단점**: 시간 할당량이 너무 짧으면 잦은 문맥 교환으로 오버헤드가 커지고, 너무 길면 FCFS와 비슷해진다.
  
#### **② SRT (Shortest Remaining Time)**
> **"남은 실행 시간이 가장 짧은 작업부터 처리"**

이는 **SJF 알고리즘의 선점형 버전**이다.
* **동작 방식**: 현재 실행 중인 프로세스의 남은 시간보다 더 짧은 실행 시간을 가진 새로운 프로세스가 준비 큐에 도착하면, 즉시 현재 프로세스를 중단(선점)하고 새로운 짧은 프로세스를 실행한다.

#### **③ MLQ (Multi-level Queue)**
> **"작업 종류에 따라 각기 다른 큐에서 처리"**

프로세스의 종류(예: 대화형 포그라운드 작업, 계산 위주 백그라운드 작업)에 따라 준비 큐를 여러 개로 분리하는 방식이다.

* **동작 방식**: 각 큐는 자신만의 독립적인 스케줄링 알고리즘을 가진다. (예: 포그라운드 큐는 RR, 백그라운드 큐는 FCFS)
* **특징**: 큐 사이에 우선순위가 있어, 포그라운드 큐가 비어 있을 때만 백그라운드 큐의 작업을 처리하는 식으로 동작한다. 한번 큐에 배정되면 다른 큐로 이동할 수 없다.

#### **④ MLFQ (Multi-level Feedback Queue)**
> **"큐 사이의 이동을 허용하여 적응성을 높인 방식"**

MLQ를 개선한 방식으로, **프로세스가 큐 사이를 이동**할 수 있다는 점이 가장 큰 차이점이다. 이는 현대 운영체제에서 가장 널리 사용되는 스케줄링 방식 중 하나이다.

* **동작 방식**:
    1.  새로운 프로세스는 가장 높은 우선순위 큐에 들어간다.
    2.  자신의 시간 할당량을 다 사용하면 우선순위가 한 단계 낮은 큐로 이동한다.
    3.  I/O 작업 등으로 대기 상태에 들어갔다가 다시 준비 상태가 되면 높은 우선순위 큐로 이동할 수 있다.
    4.  가장 낮은 우선순위 큐에서 너무 오래 기다리면, 우선순위를 높여주는 **노화(Aging)** 기법을 적용할 수 있다.
* **장점**: CPU를 짧게 사용하는 대화형 작업은 높은 우선순위를 유지하고, 오래 사용하는 CPU 집약적 작업은 낮은 우선순위로 내려가게 되어, 작업의 특성에 맞게 동적으로 우선순위를 조절할 수 있다.



네, 전체적으로 매우 정확하고 체계적으로 잘 정리했습니다. 각 알고리즘의 핵심 아이디어와 장단점을 정확히 파악하고 있습니다. 특히 마지막에 '기아 현상'과 '에이징 기법'을 중심으로 여러 알고리즘의 관계를 정리한 부분이 훌륭합니다.

현재 내용만으로도 충분하지만, 발표나 학습의 깊이를 더하기 위해 몇 가지 보충 및 개선 아이디어를 제안합니다.

-----

### **💡 목표별 스케줄링 알고리즘 분류**

알고리즘들은 저마다 다른 목표를 우선시한다.

* **공평성 (Fairness) 중시**:
    * **FCFS, Round Robin**: 모든 프로세스에게 공평한 기회를 제공하는 데 중점을 둔다.

* **시스템 효율 (평균 대기 시간 최소화) 중시**:
    * **SJF, SRT**: 시스템 전체의 평균 대기 시간을 줄여 처리량을 높이는 것을 목표로 한다.

* **기아 현상 해결 중시**:
    * **HRN**: SJF의 효율성은 유지하면서, 대기 시간을 고려하여 공평성을 보완한다.
    * **MLFQ (노화 기법)**: 낮은 우선순위 큐에서 오래 기다린 프로세스의 우선순위를 높여 기아 현상을 방지한다.

* **응답 시간 단축 중시**:
    * **Round Robin, MLFQ**: 대화형 시스템에서 사용자의 빠른 응답 경험을 보장하는 데 최적화되어 있다.
```

-----

### **심화 개념: 스케줄러와 디스패처**

스케줄링 과정을 조금 더 깊이 이해하기 위해 두 가지 역할을 구분하면 좋다.

  * **스케줄러 (Scheduler)**: **'두뇌'** 역할. 준비 큐에 있는 프로세스들 중, 스케줄링 알고리즘(예: SJF, RR)에 따라 다음에 실행할 프로세스를 **결정**한다.
  * **디스패처 (Dispatcher)**: **'손발'** 역할. 스케줄러가 결정한 프로세스에게 CPU 제어권을 **넘겨주는** 실제 작업을 수행한다. 이 과정에는 문맥 교환이 포함된다.

> 디스패처가 하나의 프로세스를 멈추고 다른 프로세스를 시작하는 데까지 걸리는 시간을 \*\*디스패치 지연 시간(Dispatch Latency)\*\*이라고 하며, 이것이 문맥 교환 오버헤드의 일부이다.

-----

### **결론**
어떤 단일 알고리즘도 모든 상황에서 최고일 수는 없다. 따라서 현대의 운영체제(Windows, macOS, Linux 등)는 단일 알고리즘을 사용하기보다는, **여러 스케줄링 알고리즘을 조합**한 **다단계 큐 스케줄링(Multi-level Queue Scheduling)**과 같은 복합적인 방식을 사용하여, 대화형 작업, 시스템 작업, 백그라운드 작업 등 각 프로세스의 특성에 맞게 CPU를 동적으로 할당한다.